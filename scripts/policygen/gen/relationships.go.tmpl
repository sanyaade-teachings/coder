type Obj{{ capitalize .Name }} struct {
	Obj *v1.ObjectReference
	OptionalRelation string
	Builder *Builder
}

func (b *Builder){{ capitalize .Name }}(id fmt.Stringer) *Obj{{ capitalize .Name }} {
	o := &Obj{{ capitalize .Name }}{
		Obj: &v1.ObjectReference{
			ObjectType: "{{ .Name }}",
			ObjectId:   id.String(),
		},
		Builder: b,
	}
	return o
}

{{ $filename := .Filename }}
{{ $outerName := .Name }}
func (obj *Obj{{ capitalize $outerName }}) Object() *v1.ObjectReference {
	return obj.Obj
}

func (obj *Obj{{ capitalize $outerName }}) AsSubject() *v1.SubjectReference {
	return &v1.SubjectReference{
		Object:           obj.Object(),
		OptionalRelation: obj.OptionalRelation,
	}
}

{{ range $index, $element := .DirectRelations }}
{{/* Wildcard '*' is a keyword for spicedb to represent 'all objects of this type' */}}
{{ if eq $element.Subject.Object.ObjectId "*" }}
// {{ capitalize $element.RelationName }}Wildcard {{ $filename }}:{{ .LinePos }}
{{ comment $element.Comment }}
func (obj *Obj{{ capitalize $outerName }}) {{ capitalize $element.RelationName }}Wildcard() *Obj{{ capitalize $outerName }}{
	obj.Builder.AddRelationship(v1.Relationship{
		Resource: obj.Obj,
		Relation: "{{ $element.RelationName }}",
		Subject: &v1.SubjectReference{
			Object: &v1.ObjectReference {
				ObjectType: "{{ $element.Subject.Object.ObjectType }}",
				ObjectId: "*",
			},
			OptionalRelation: "{{ $element.Subject.OptionalRelation }}",
		},
		OptionalCaveat: nil,
	})
	return obj
}

{{ else }}
// {{ capitalize $element.FunctionName }} {{ $filename }}:{{ .LinePos }}
{{ comment $element.Comment }}
func (obj *Obj{{ capitalize $outerName }}) {{ capitalize $element.FunctionName }}(subs ...*Obj{{ capitalize $element.Subject.Object.ObjectType }}) *Obj{{ capitalize $outerName }}{
	for i := range subs {
		sub := subs[i]
		obj.Builder.AddRelationship(v1.Relationship{
			Resource: obj.Obj,
			Relation: "{{ $element.RelationName }}",
			Subject: &v1.SubjectReference{
				Object: sub.Obj,
				OptionalRelation: "{{ $element.Subject.OptionalRelation }}",
			},
			OptionalCaveat: nil,
		})
	}
	return obj
}
{{ end }}
{{ end }}


{{ range $index, $element := .Permissions }}

{{/* The context argument is added for easier use of the Check function. */}}
// Can{{ capitalize $element.FunctionName }} {{ $filename }}:{{ .LinePos }}
{{ comment $element.Comment }}
func (obj *Obj{{ capitalize $outerName }}) Can{{ capitalize $element.FunctionName }}(ctx context.Context) (context.Context, string, *v1.ObjectReference) {
	return ctx, "{{ $element.Permission }}", obj.Object()
}

{{/*
	The subject is almost always going to be an *ObjUser, but we should account for non-user subjects.
	If we end up only using users here, we should replace 'AuthzedObject' with '*ObjUser' in the function signature for
	type safety.
*/}}
{{/*func (obj *Obj{{ capitalize $outerName }}) Can{{ capitalize $element.FunctionName }}By(subs ...AuthzedObject) *Obj{{ capitalize $outerName }}{*/}}
{{/*	for i := range subs {*/}}
{{/*		sub := subs[i]*/}}
{{/*		obj.Builder.CheckPermission(sub, "{{ $element.Permission }}", obj)*/}}
{{/*	}*/}}
{{/*	return obj*/}}
{{/*}*/}}



{{ end }}


{{ range $index, $element := .IncludeRelations }}
{{/*
	I really dislike this one, but things feel incomplete without it.
	When doing things like, "Can group X do Y?", you really need to check:
	"Can any 'member' in group X do Y?"
*/}}

// AsAny{{ capitalize .RelationName }}
{{- range $_, $from := $element.From }}
// {{ $from }}
{{- end }}
func (obj *Obj{{ capitalize $outerName }}) AsAny{{ capitalize .RelationName }}() *Obj{{ capitalize $outerName }} {
	return &Obj{{ capitalize $outerName }}{
		Obj:           obj.Object(),
		OptionalRelation: "{{.RelationName }}",
		Builder:          obj.Builder,
	}
}

{{ end }}
